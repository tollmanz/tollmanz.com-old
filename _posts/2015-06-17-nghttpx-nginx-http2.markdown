---
layout:     post
title:      "Taking HTTP/2 for a Spin with Nghttpx"
date:       2015-06-17 22:45:00
categories: http2, performance, nginx
---

HTTP/2 is here. Well...kinda. All major browsers currently support HTTP/2 or have publicly announced intentions to support it. Finding server software that supports HTTP/2 is a little trickier though. Nginx and Apache, the two biggest server applications do not currently support HTTP/2. What's a web geek to do? Fortunately, a hot little HTTP/2 server is currently available and ready for use. It has been around for a little over a year and I finally decided to take it for a spin. In fact, my site is offering an HTTP/2 connection via nghttpx right now.

Getting nghttpx up and running was surprisingly easy, especially given that there is little information out there beyond the documentation itself. In this article, I will discuss my experiences with nghttpx and HTTP/2, as well as dive into some instructions for installing and configuring the software.

## What is Nghttpx?

Nghttpx is an HTTP/2 proxy implemented on top of Nghttp2. Nghttp2 is an HTTP/2 implementation in C. When you install the Nghttp2 package, you get a client, server, proxy, and related tools. Nghttpx is the proxy that I will focus on in this article. I decided to go with the proxy over the server implementation because I wanted to recycle the work I've done to configure Nginx for serving my site, rather than having to learn how to configure a new piece of server software.

I've implemented Nghttpx as a reverse proxy. Requests to my website on port 443 are handled by Nghttpx, which proxies the request to Nginx. Nginx ultimately handles all of the request routing to return the requested files. In turn, it hands the response off to Nghttpx which ultimately prepares the HTTP/2 response for the client.

I have been excited about HTTP/2, but have worried about potential difficulties of supporting HTTP/2, HTTP/1.1, and SPDY. Nghttpx takes away some of this hassle in that it'll work with the following protocols by default:

* HTTP/2
* HTTP/2 draft 16
* HTTP/2 draft 14
* SPDY 3.1
* HTTP 1.1



## A Solid TLS Configuration

One of my hesitations with server software other than Nginx is that I really enjoy all of the TLS configuration options that Nginx offers. It implements the widest array of TLS configuration options that I am aware of. If I used a different server to get HTTP/2, my biggest concern was having to trade an "A+" TLS configuration for the features of HTTP/2 (until Nginx itself supported HTTP/2).

To my surprise, Nghttpx's TLS configuration is just as powerful as Nginx's. Moreover, the default Nghttpx TLS configuration will produce an "A" rating on [SSL Labs](https://ssllabs.com). Let me repeat that, without any special configuration, Nghttpx provides a best in class TLS configuration out of the box. In fact, the other TLS configuration required was the path to my private key and public certificate chain.


SAY SOMETHING ABOUT NGINX'S DEFAULT?


To contextualize this, [SSL Pulse's](https://www.trustworthyinternet.org/ssl-pulse/) June 11, 2015 data suggests that only 18.8% of ~146k top rated Alexa sites tested received an "A-" rating or higher from SSL Labs. A site with less that an "A-" is characterized as having "inadequate security" due to at least one major flaw in the TLS configuration. It's noteworthy for a piece of software to ship with such solid out of the box TLS configuration. Efforts like these help make it much more difficult for implementors to naively implement less than ideal TLS configuration.

The TLS defaults for Nghttpx are:

* Protocol version: TLSv1.2, TLSv1.1
* The [default cipher suites](https://github.com/tatsuhiro-t/nghttp2/blob/90bcdb0dda83212ac83f2dbd4abfdf90926ce3cb/src/ssl.cc#L42-L50) are:

 {% highlight bash %}
ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:
ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:
kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:
ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:
ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:
DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:
!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
 {% endhighlight %}

* OCSP stapling is turned on by default
* Secure connections are the default, even though HTTP/2 does not require TLS
* No static Diffie-Hellman parameters are generated by default as DHE key exchange is not supported unless you provide your own

Basically, if you implement a secure connection in Nginx today, you need to take care to configure these things specifically. If you don't, you may find yourself susceptible to a TLS-related vulnerability.

Another really welcome surprise was the transparency about OCSP when I fired up the server. After starting the server, I found the following in my logs:

 {% highlight bash %}
7/Jun/2015:21:46:00 -0400 PID32679 [NOTICE] Listening on 0.0.0.0, port 443
17/Jun/2015:21:46:00 -0400 PID32679 [NOTICE] Renew ticket keys: main
fetch-ocsp-response (using OpenSSL 1.0.1f 6 Jan 2014)
sending OCSP request to http://gv.symcd.com
/etc/ssl/usr-certs/tollmanz.crt: good
  This Update: Jun 15 00:50:23 2015 GMT
  Next Update: Jun 22 00:50:23 2015 GMT

verifying the response signature
verify OK (used: [u'-VAfile', u'/tmp/tmpxUTr9K/issuer.crt'])
 {% endhighlight %}

The processes behind OCSP can be a bit of a black box at times because of the lack of transparency. I really liked that nghttpx told me that it was making the request, the result of the request and when the next request would occur. Oh, and guess what? You can configure that request interval.

If it isn't apparent, I was very pleased with the TLS configuration. At best, I thought I'd have to configure it to my liking. At worst, I thought I wouldn't be able to configure it as desired. In the end, I got a perfectly configured server for TLS out of the box.
